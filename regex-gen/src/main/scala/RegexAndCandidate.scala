<<<<<<< HEAD
package ceedubs.irrec
package regex

import org.scalacheck.{Arbitrary, Gen}

final case class RegexAndCandidate[A](r: Regex[A], candidate: Stream[A])

object RegexAndCandidate {

  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genRegexAndMatch]].
   */
  def genCandidateStream[A](matchToGen: Match[A] => Gen[A]): Regex[A] => Gen[Stream[A]] = {
    val matching = RegexMatchGen.regexMatchingStreamGen(matchToGen)
    r => Gen.oneOf(matching(r), Gen.containerOf[Stream, A](matchToGen(Match.wildcard)))
  }

  /**
   * Generate a regular expression and a stream that matches the regular expression.
   */
  def genRegexAndMatch[A](
    cfg: RegexGen.Config[A],
    matchToGen: Match[A] => Gen[A]): Gen[RegexAndCandidate[A]] =
    for {
      r <- RegexGen.genRegex(cfg)
      c <- RegexMatchGen.regexMatchingStreamGen(matchToGen)(r)
    } yield RegexAndCandidate(r, c)

  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[A](
    cfg: RegexGen.Config[A],
    matchToGen: Match[A] => Gen[A]): Gen[RegexAndCandidate[A]] = {
    val probablyNotMatching = for {
      r <- RegexGen.genRegex(cfg)
      c <- Gen.containerOf[Stream, A](cfg.genA)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[A](cfg, matchToGen))
  }

  val genByteRegexAndMatch: Gen[RegexAndCandidate[Byte]] =
    genRegexAndMatch(RegexGen.standardByteConfig, RegexMatchGen.byteMatchingGen)

  val genIntRegexAndMatch: Gen[RegexAndCandidate[Int]] =
    genRegexAndMatch(RegexGen.standardIntConfig, RegexMatchGen.intMatchingGen)

  val genLongRegexAndMatch: Gen[RegexAndCandidate[Long]] =
    genRegexAndMatch(RegexGen.standardLongConfig, RegexMatchGen.longMatchingGen)

  implicit val arbRegexAndCandidateChar: Arbitrary[RegexAndCandidate[Char]] = Arbitrary(
    CharRegexGen.genCharRegexAndCandidate)

  implicit val arbRegexAndCandidateByte: Arbitrary[RegexAndCandidate[Byte]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardByteConfig, RegexMatchGen.byteMatchingGen))

  implicit val arbRegexAndCandidateInt: Arbitrary[RegexAndCandidate[Int]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardIntConfig, RegexMatchGen.intMatchingGen))

  implicit val arbRegexAndCandidateLong: Arbitrary[RegexAndCandidate[Long]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardLongConfig, RegexMatchGen.longMatchingGen))
}
||||||| merged common ancestors
=======
package ceedubs.irrec
package regex

import ceedubs.irrec.regex.{RegexGen => RegexGenOld}
import ceedubs.irrec.regex.{RegexMatchGen => RegexMatchGenOld}

import org.scalacheck.{Arbitrary, Cogen, Gen}
import cats.Order
import cats.implicits._

final case class RegexAndCandidate[In, Out](r: RegexM[In, Out], candidate: Stream[In])

object RegexAndCandidate {
  /**
   * Generate a regular expression and a stream that matches the regular expression.
   */
  def genRegexAndMatch[In: Cogen: Order, Out: Arbitrary: Cogen](
    cfg: RegexGenOld.Config[In],
    matchToGen: Match[In] => Gen[In]): Gen[RegexAndCandidate[In, Out]] =
    for {
      r <- RegexGen.genRegex[In, Out](cfg)
      c <- RegexMatchGen.regexMatchingStreamGen(matchToGen)(r)
    } yield RegexAndCandidate(r, c)

  def genIntRegexAndMatch[Out: Arbitrary: Cogen]: Gen[RegexAndCandidate[Int, Out]] =
    genRegexAndMatch(RegexGenOld.standardIntConfig, RegexMatchGen.intMatchingGen)

  // TODO universal instead of existential type for Regex[In, _]?
  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genRegexAndMatch]].
   */
  def genCandidateStream[In](matchToGen: Match[In] => Gen[In]): RegexM[In, _] => Gen[Stream[In]] = {
    val matching = RegexMatchGen.regexMatchingStreamGen(matchToGen)
    r => Gen.oneOf(matching(r), Gen.containerOf[Stream, In](matchToGen(Match.wildcard)))
  }

  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[In: Cogen: Order, Out: Arbitrary: Cogen](
    cfg: RegexGenOld.Config[In],
    matchToGen: Match[In] => Gen[In]): Gen[RegexAndCandidate[In, Out]] = {
    val probablyNotMatching = for {
      r <- RegexGen.genRegex[In, Out](cfg)
      c <- Gen.containerOf[Stream, In](cfg.genA)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[In, Out](cfg, matchToGen))
  }

  implicit def arbRegexAndCandidateByte[Out: Arbitrary: Cogen]
    : Arbitrary[RegexAndCandidate[Byte, Out]] =
    Arbitrary(
      genRegexAndCandidate(RegexGenOld.standardByteConfig, RegexMatchGenOld.byteMatchingGen))

  implicit def arbRegexAndCandidateChar[Out: Arbitrary: Cogen]
    : Arbitrary[RegexAndCandidate[Char, Out]] =
    Arbitrary(CharRegexGen.genRegexAndCandidate[Out])

  implicit def arbRegexAndCandidateInt[Out: Arbitrary: Cogen]
    : Arbitrary[RegexAndCandidate[Int, Out]] =
    Arbitrary(genRegexAndCandidate(RegexGenOld.standardIntConfig, RegexMatchGenOld.intMatchingGen))

  implicit def arbRegexAndCandidateLong[Out: Arbitrary: Cogen]
    : Arbitrary[RegexAndCandidate[Long, Out]] =
    Arbitrary(
      genRegexAndCandidate(RegexGenOld.standardLongConfig, RegexMatchGenOld.longMatchingGen))
}
>>>>>>> Remove applicative dir
