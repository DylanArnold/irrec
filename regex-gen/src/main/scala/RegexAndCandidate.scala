package ceedubs.irrec
package regex

import org.scalacheck.{Arbitrary, Gen}

final case class RegexAndCandidate[A](r: Regex[A], candidate: Stream[A])

// TODO ceedubs passing around available and weight a lot in here. Is there a better way?
object RegexAndCandidate {

  /**
   * Generate a stream that matches the provided regular expression.
   */
  //def genMatchingStream[A](r: Regex[A], genA: Gen[A])(
  //  implicit chooseA: Choose[A],
  //  orderA: Order[A]): Gen[Stream[A]] =
  //  regexMatchingStreamGen(genA).apply(r)

  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genMatchingStream]].
   */
  def genCandidateStream[A](matchToGen: Match[A] => Gen[A]): Regex[A] => Gen[Stream[A]] = {
    val matching = RegexMatchGen.regexMatchingStreamGen(matchToGen)
    r => Gen.oneOf(matching(r), Gen.containerOf[Stream, A](matchToGen(Match.wildcard)))
  }

  // TODO ceedubs
  def genRegexAndMatch[A](
    cfg: RegexGen.Config[A],
    matchToGen: Match[A] => Gen[A]): Gen[RegexAndCandidate[A]] =
    for {
      r <- RegexGen.genRegex(cfg)
      c <- RegexMatchGen.regexMatchingStreamGen(matchToGen)(r)
    } yield RegexAndCandidate(r, c)

  // TODO ceedubs
  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[A](
    cfg: RegexGen.Config[A],
    matchToGen: Match[A] => Gen[A]): Gen[RegexAndCandidate[A]] = {
    val probablyNotMatching = for {
      r <- RegexGen.genRegex(cfg)
      c <- Gen.containerOf[Stream, A](cfg.gen)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[A](cfg, matchToGen))
  }

  // TODO ceedubs
  /**
   * @see [[genRegexAndCandidate]]
   */
  //def arbRegexAndCandidate[A](
  //  implicit arbA: Arbitrary[A],
  //  chooseA: Choose[A],
  //  orderingA: Ordering[A]): Arbitrary[RegexAndCandidate[A]] = {
  //  implicit val orderA: Order[A] = Order.fromOrdering(orderingA)
  //  Arbitrary(
  //    genRegexAndCandidate(
  //      arbA.arbitrary,
  //      genRangeMatch(arbA.arbitrary),
  //      includeZero = true,
  //      includeOne = true))
  //}

  val genByteRegexAndMatch: Gen[RegexAndCandidate[Byte]] =
    genRegexAndMatch(RegexGen.standardByteConfig, RegexMatchGen.byteMatchingGen)

  val genIntRegexAndMatch: Gen[RegexAndCandidate[Int]] =
    genRegexAndMatch(RegexGen.standardIntConfig, RegexMatchGen.intMatchingGen)

  val genLongRegexAndMatch: Gen[RegexAndCandidate[Long]] =
    genRegexAndMatch(RegexGen.standardLongConfig, RegexMatchGen.longMatchingGen)

  implicit val arbRegexAndCandidateChar: Arbitrary[RegexAndCandidate[Char]] = Arbitrary(
    CharRegexGen.genCharRegexAndCandidate)

  implicit val arbRegexAndCandidateByte: Arbitrary[RegexAndCandidate[Byte]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardByteConfig, RegexMatchGen.byteMatchingGen))

  implicit val arbRegexAndCandidateInt: Arbitrary[RegexAndCandidate[Int]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardIntConfig, RegexMatchGen.intMatchingGen))

  implicit val arbRegexAndCandidateLong: Arbitrary[RegexAndCandidate[Long]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardLongConfig, RegexMatchGen.longMatchingGen))
}
