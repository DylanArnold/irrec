package ceedubs.irrec
package regex

import ceedubs.irrec.regex.RegexGen._
import org.scalacheck.Gen, Gen.Choose
import org.scalacheck.Arbitrary

final case class RegexAndCandidate[A](r: Regex[A], candidate: Stream[A])

object RegexAndCandidate {

  /**
   * Generate a stream that matches the provided regular expression.
   */
  def genMatchingStream[A](r: Regex[A], genA: Gen[A])(implicit chooseA: Choose[A]): Gen[Stream[A]] =
    regexMatchingStreamGen(genA).apply(r)

  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genMatchingStream]].
   */
  def genCandidateStream[A](r: Regex[A], genA: Gen[A])(implicit chooseA: Choose[A]): Gen[Stream[A]] =
    Gen.oneOf(genMatchingStream(r, genA), Gen.containerOf[Stream, A](genA))

  def genRegexAndMatch[A](includeOne: Boolean, genA: Gen[A])(implicit chooseA: Choose[A], orderingA: Ordering[A]): Gen[RegexAndCandidate[A]] =
    for {
      r <- genRegex(genA, includeZero = false, includeOne = includeOne)
      c <- genMatchingStream(r, genA)
    } yield RegexAndCandidate(r, c)

  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[A](genA: Gen[A], includeZero: Boolean, includeOne: Boolean)(implicit chooseA: Choose[A], orderingA: Ordering[A]): Gen[RegexAndCandidate[A]] = {
    val probablyNotMatching = for {
      r <- genRegex(genA, includeZero = includeZero, includeOne = includeOne)
      c <- Gen.containerOf[Stream, A](genA)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[A](includeOne = includeOne, genA))
  }

  /**
   * @see [[genRegexAndCandidate]]
   */
  implicit def arbRegexAndCandidate[A](implicit arbA: Arbitrary[A], chooseA: Choose[A], orderingA: Ordering[A]): Arbitrary[RegexAndCandidate[A]] =
    Arbitrary(genRegexAndCandidate(arbA.arbitrary, includeZero = true, includeOne = true))
}
