package ceedubs.irrec
package regex

import ceedubs.irrec.regex.RegexGen._
import ceedubs.irrec.regex.CharRegexGen.genCharRegexAndCandidate
import org.scalacheck.Gen, Gen.Choose
import org.scalacheck.Arbitrary

final case class RegexAndCandidate[A](r: Regex[A], candidate: Stream[A])

object RegexAndCandidate {

  /**
   * Generate a stream that matches the provided regular expression.
   */
  def genMatchingStream[A](r: Regex[A], genA: Gen[A])(implicit chooseA: Choose[A]): Gen[Stream[A]] =
    regexMatchingStreamGen(genA).apply(r)

  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genMatchingStream]].
   */
  def genCandidateStream[A](r: Regex[A], genA: Gen[A])(implicit chooseA: Choose[A]): Gen[Stream[A]] =
    Gen.oneOf(genMatchingStream(r, genA), Gen.containerOf[Stream, A](genA))

  def genRegexAndMatch[A](includeOne: Boolean, genA: Gen[A], genRangeA: Gen[Match.Range[A]])(implicit chooseA: Choose[A]): Gen[RegexAndCandidate[A]] =
    for {
      r <- genRegex(genA, genRangeA, includeZero = false, includeOne = includeOne)
      c <- genMatchingStream(r, genA)
    } yield RegexAndCandidate(r, c)

  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[A](genA: Gen[A], genRangeA: Gen[Match.Range[A]], includeZero: Boolean, includeOne: Boolean)(implicit chooseA: Choose[A]): Gen[RegexAndCandidate[A]] = {
    val probablyNotMatching = for {
      r <- genRegex(genA, genRangeA, includeZero = includeZero, includeOne = includeOne)
      c <- Gen.containerOf[Stream, A](genA)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[A](includeOne = includeOne, genA, genRangeA))
  }

  /**
   * @see [[genRegexAndCandidate]]
   */
  def arbRegexAndCandidate[A](implicit arbA: Arbitrary[A], chooseA: Choose[A], orderingA: Ordering[A]): Arbitrary[RegexAndCandidate[A]] =
    Arbitrary(genRegexAndCandidate(arbA.arbitrary, genRangeMatch(arbA.arbitrary), includeZero = true, includeOne = true))

  implicit val arbRegexAndCandidateChar: Arbitrary[RegexAndCandidate[Char]] = Arbitrary(genCharRegexAndCandidate)

  implicit val arbRegexAndCandidateByte: Arbitrary[RegexAndCandidate[Byte]] = arbRegexAndCandidate[Byte]

  implicit val arbRegexAndCandidateInt: Arbitrary[RegexAndCandidate[Int]] = arbRegexAndCandidate[Int]

  implicit val arbRegexAndCandidateLong: Arbitrary[RegexAndCandidate[Long]] = arbRegexAndCandidate[Long]
}
