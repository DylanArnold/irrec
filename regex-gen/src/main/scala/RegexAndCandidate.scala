package ceedubs.irrec
package regex

import org.scalacheck.{Arbitrary, Gen}

final case class RegexAndCandidate[A](r: Regex[A], candidate: Stream[A])

object RegexAndCandidate {

  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genRegexAndMatch]].
   */
  def genCandidateStream[A](matchToGen: Match[A] => Gen[A]): Regex[A] => Gen[Stream[A]] = {
    val matching = RegexMatchGen.regexMatchingStreamGen(matchToGen)
    r => Gen.oneOf(matching(r), Gen.containerOf[Stream, A](matchToGen(Match.wildcard)))
  }

  /**
   * Generate a regular expression and a stream that matches the regular expression.
   */
  def genRegexAndMatch[A](
    cfg: RegexGen.Config[A],
    matchToGen: Match[A] => Gen[A]): Gen[RegexAndCandidate[A]] =
    for {
      r <- RegexGen.genRegex(cfg)
      c <- RegexMatchGen.regexMatchingStreamGen(matchToGen)(r)
    } yield RegexAndCandidate(r, c)

  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[A](
    cfg: RegexGen.Config[A],
    matchToGen: Match[A] => Gen[A]): Gen[RegexAndCandidate[A]] = {
    val probablyNotMatching = for {
      r <- RegexGen.genRegex(cfg)
      c <- Gen.containerOf[Stream, A](cfg.genA)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[A](cfg, matchToGen))
  }

  val genByteRegexAndMatch: Gen[RegexAndCandidate[Byte]] =
    genRegexAndMatch(RegexGen.standardByteConfig, RegexMatchGen.byteMatchingGen)

  val genIntRegexAndMatch: Gen[RegexAndCandidate[Int]] =
    genRegexAndMatch(RegexGen.standardIntConfig, RegexMatchGen.intMatchingGen)

  val genLongRegexAndMatch: Gen[RegexAndCandidate[Long]] =
    genRegexAndMatch(RegexGen.standardLongConfig, RegexMatchGen.longMatchingGen)

  implicit val arbRegexAndCandidateChar: Arbitrary[RegexAndCandidate[Char]] = Arbitrary(
    CharRegexGen.genCharRegexAndCandidate)

  implicit val arbRegexAndCandidateByte: Arbitrary[RegexAndCandidate[Byte]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardByteConfig, RegexMatchGen.byteMatchingGen))

  implicit val arbRegexAndCandidateInt: Arbitrary[RegexAndCandidate[Int]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardIntConfig, RegexMatchGen.intMatchingGen))

  implicit val arbRegexAndCandidateLong: Arbitrary[RegexAndCandidate[Long]] = Arbitrary(
    genRegexAndCandidate(RegexGen.standardLongConfig, RegexMatchGen.longMatchingGen))
}
